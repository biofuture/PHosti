#!/usr/bin/perl -w
use strict;

my $usage = <<USAGE;

	Authur: Xiao-Tao Jiang
	Email: biofuture.jiang\@gmail.com
	Date: 2016/06/28

	PHosti -i <input_fasta> -o <output_directory> -h

	-i <input fasta>	Contain phage genomes/contigs to detect host for
	-o <out_directory>	For each fasta sequence (genome/contig/scaffold), predict the Bacteria/Archaea host
	-m [model file]		Model file to do prediction for which was generated by the training step
	-p [id to taxa map]	The mapping file for the hostdb which record the ids in the tree mapping to their phylogenetic information
	-l [fragment length]	The length to split the input fasta sequences for kmer profile generation, default 10000	
	-f [kmer from]		Generate kmer profile start from this length of kmer default 4
	-t [kmer to]		Generate kmer prfile end at the length of kmer default 6 
	-h 			Help information print
USAGE

use Getopt::Std;
use FindBin qw($Bin);

##Preload current directory into PERL @INC directory using BEGIN block
BEGIN {
    my $PHostidir = $Bin;
    unshift @INC, $PHostidir;
}
##----------------------------------------------------

our $PHostidir = $Bin;
our($opt_i, $opt_o, $opt_l, $opt_m, $opt_p, $opt_f, $opt_t, $opt_h)="";
getopts('i:o:m:l:p:f:t:h');
my $date = localtime;
##--------------------------------------------------------

#my $model = "$PHostidir/db/TRIAN_MODELUNEW2t0v1o2z1c1000.svm";
my $id2tax = "$PHostidir/db/ID2taxa.map";
my $classifybin = "$PHostidir/bin/svm_phylo_classify";
my $fa2kmer = "$PHostidir/bin/fasta2kmers2";

##-------------------------------------------------------------------

if($opt_h || ($opt_i eq "")){ die $usage; }  ##Print help information
##----------------------------------------------------------

##Process input fasta to generate the Kmer Profile
die "$! $opt_i\n" unless open(IN, "$opt_i");
#split fasta in to length of l and generate Kmer profile for all selected kmers 
$/ = ">";
$opt_l ||= 5000;
$opt_m ||= "$PHostidir/db/TRIAN_MODELUNEW2t0v1o2z1c1000.svm";
$opt_p ||= "$PHostidir/db/ID2taxa.map";
$opt_f ||= 4;
$opt_t ||= 6;

my $leng = $opt_l;

unless(-d "$opt_o"){ `mkdir $opt_o`;}
unless(-d "$opt_o/Samplefasta"){ `mkdir $opt_o/Samplefasta`;}
my $opt_prefix = $opt_i; $opt_prefix =~ s/\.fa$//; $opt_prefix =~ s/\.fasta$//;##Generate output prefix
my $ocfa = "$opt_o/Samplefasta/$opt_prefix\_cut_$leng\.fasta";
die "$!\n" unless open(CFA, ">$ocfa"); #OUTPUT split sequences into fa

<IN>;
while(<IN>){
	chomp;
	my @ts = split("\n",$_, 2);
	$ts[1] =~ s/\n//g; 	
	my $ofragment = cut_seqs($ts[0], $ts[1], $leng);	
	if($ofragment ne "Nil"){
		print CFA "$ofragment\n";
	}
}
close IN;
close CFA;
$/="\n";
#-------------------------------------------------------------------------------------

##Prediction with previous constructed model.
die "$ocfa was not correctly generated\n" unless(-e $ocfa);
my $kprof = "$opt_o/Samplefasta/$opt_prefix\_cut_$leng\.kprof";
#Kmer profile
`$fa2kmer -i $ocfa -f $kprof -j $opt_f -k $opt_t -a w -s 1 -l 2 -o 1 -b 1 -R 1 -h 1 -n 1`;
die "$kprof was not correctly generated\n" unless(-e $kprof);

unless(-d "$opt_o/Predict"){ `mkdir $opt_o/Predict`;}
my $kpredict = "$opt_o/Predict/$opt_prefix\_cut$leng.predict";
#Prediction with already generated SVM model
`$classifybin -v 0 --o 2 $kprof $opt_m $kpredict`;
die "Predicting $kpredict file was not correctly generated\n" unless(-e $kpredict);
#-------------------------------------------------------------------------------------------

##Integration of predicted results and generate output tabular format restuls
#parse the  predict
die "$!\n" unless open(KP, "$kpredict");
#die "$!\n" unless open(MAP, "$id2tax");
die "$!\n" unless open(MAP, "$opt_p");
my %i2tax; ##store node id mapping to taxonomy lineage in database
while(<MAP>){
	chomp;
	my @tem = split /\t/;
	$i2tax{$tem[0]} = $tem[1];
}
close MAP;

my %seq2tax; ##store the fasta sequences predicted ids 
while(<KP>){
	chomp;
	my @tem = split /\t/;
	$seq2tax{$tem[0]}{$tem[5]} = $tem[2]; 
}
close KP;
##------------------------------------------------------------------------------------

die "$!\n" unless open(OUT, ">$opt_o/$opt_prefix\.predict.host.txt");
print OUT "SequencesID\tHost Phylogeny\n";
for my $seqid (keys %seq2tax){
	
	my @tem = ();
	for my $dbid (keys %{$seq2tax{$seqid}} ){
		die "$dbid\n" unless(exists $i2tax{$dbid});		
		push @tem, $i2tax{$dbid};
	}

	my $otax = lca(@tem);
	print OUT "$seqid\t$otax\n";
}
close OUT;
##----------------------------------------------------------------------------




##merge all annotation to each fragment sequences and generation of concensus taxonomy with Local Common Ancester
sub lca{
        my @all = @_;
        my @total = ();

        ##split each taxonomy by "; " 

        my $i = 0;
        my $j = 0;
        my $index = 8;
        ##store in matrix and transform column to row
        for($i = 0; $i <= $#all; $i++){
                my @tem = split("; ", $all[$i]);
                if($#tem <= $index ){ $index = $#tem;}

                #die "$all[$i]" if($#tem != 6);
                for($j = 0; $j <= $#tem; $j++){
                        $total[$j][$i] = $tem[$j];
                }
        }

        my $k = 0;
        for(;$k <= $index; $k++){
                my $flag = 0;

                my %temp = ();

                for(my $l = 1; $l <= $#all; $l++){
                        if($total[$k][$l] ne $total[$k][0]){
                                $flag = 1;
                                last;
                        }
                }

                if($flag == 1){
                        last;
                }

        }
        my @common = ();
        for(my $oi= 0; $oi < $k; $oi++){
                push @common, $total[$oi][0];
        }
        return join("; ",  @common);
}#lca

#Split seqs into a length fragment
sub cut_seqs{
	my ($id, $seq, $len) = @_;
	my $tlen = length($seq);
	
	my $index = int($tlen/$len);
	
	if($index == 0 && $tlen < 0.5 * $len){
		return "Nil";
	}elsif($index == 0 && $tlen >= 0.5 * $len){
		my $oseq = join("\n", ">$id\tFragment_0", $seq);
		
	}else{
		my @tem = ();
		for(my $i = 0; $i <= $index; $i++){
			my $ofrag = substr($seq, $i * $index, $len);
			my $oid = join("\t", ">$id", "Fragment_$i");
			my $oseq = join("\n", $oid, $ofrag);
			push @tem, $oseq;		
		}
		##the left fragment of sequences shorter than $len; if over 50% of the $len then keep it
		if( $tlen - ($index * $len) >= 0.5 * $len){
			my $ofrag = substr($seq, $len * $index, ($tlen - $index * $len) );
			my $oind = $index + 1;
			my $oid = join("\t", ">$id", "Fragment_$oind");
			my $oseq = join("\n", $oid, $ofrag);
			push @tem, $oseq;		 
		}
		##ouput all the fragemnted sequences
		return join("\n", @tem);
	}
}#cut_seqs



1;
__END__

